{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as React from \"react\";\nimport { Clipboard } from \"./common/clipboard\";\nimport { Direction } from \"./common/direction\";\nimport * as FocusedCellUtils from \"./common/internal/focusedCellUtils\";\nimport * as SelectionUtils from \"./common/internal/selectionUtils\";\nimport { RegionCardinality, Regions } from \"./regions\";\n\nvar TableHotkeys = function () {\n  function TableHotkeys(props, state, grid, tableHandlers) {\n    var _this = this;\n\n    this.props = props;\n    this.state = state;\n    this.grid = grid;\n    this.tableHandlers = tableHandlers; // Selection\n    // =========\n\n    this.selectAll = function (shouldUpdateFocusedCell) {\n      var selectionHandler = _this.tableHandlers.getEnabledSelectionHandler(RegionCardinality.FULL_TABLE); // clicking on upper left hand corner sets selection to \"all\"\n      // regardless of current selection state (clicking twice does not deselect table)\n\n\n      selectionHandler([Regions.table()]);\n\n      if (shouldUpdateFocusedCell) {\n        var newFocusedCellCoordinates = Regions.getFocusCellCoordinatesFromRegion(Regions.table());\n\n        _this.tableHandlers.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));\n      }\n    };\n\n    this.handleSelectAllHotkey = function (e) {\n      // prevent \"real\" select all from happening as well\n      e.preventDefault();\n      e.stopPropagation(); // selecting-all via the keyboard should not move the focused cell.\n\n      _this.selectAll(false);\n    };\n\n    this.handleSelectionResizeUp = function (e) {\n      return _this.handleSelectionResize(e, Direction.UP);\n    };\n\n    this.handleSelectionResizeDown = function (e) {\n      return _this.handleSelectionResize(e, Direction.DOWN);\n    };\n\n    this.handleSelectionResizeLeft = function (e) {\n      return _this.handleSelectionResize(e, Direction.LEFT);\n    };\n\n    this.handleSelectionResizeRight = function (e) {\n      return _this.handleSelectionResize(e, Direction.RIGHT);\n    };\n\n    this.handleSelectionResize = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n\n      if (selectedRegions.length === 0) {\n        return;\n      }\n\n      var index = FocusedCellUtils.getFocusedOrLastSelectedIndex(selectedRegions, focusedCell);\n      var region = selectedRegions[index];\n      var nextRegion = SelectionUtils.resizeRegion(region, direction, focusedCell);\n\n      _this.updateSelectedRegionAtIndex(nextRegion, index);\n    }; // Focus\n    // =====\n\n\n    this.handleFocusMoveLeft = function (e) {\n      return _this.handleFocusMove(e, \"left\");\n    };\n\n    this.handleFocusMoveLeftInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"left\");\n    };\n\n    this.handleFocusMoveRight = function (e) {\n      return _this.handleFocusMove(e, \"right\");\n    };\n\n    this.handleFocusMoveRightInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"right\");\n    };\n\n    this.handleFocusMoveUp = function (e) {\n      return _this.handleFocusMove(e, \"up\");\n    };\n\n    this.handleFocusMoveUpInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"up\");\n    };\n\n    this.handleFocusMoveDown = function (e) {\n      return _this.handleFocusMove(e, \"down\");\n    };\n\n    this.handleFocusMoveDownInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"down\");\n    }; // no good way to call arrow-key keyboard events from tests\n\n    /* istanbul ignore next */\n\n\n    this.handleFocusMove = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var focusedCell = _this.state.focusedCell;\n\n      if (focusedCell == null) {\n        // halt early if we have a selectedRegionTransform or something else in play that nixes\n        // the focused cell.\n        return;\n      }\n\n      var newFocusedCell = {\n        col: focusedCell.col,\n        focusSelectionIndex: 0,\n        row: focusedCell.row\n      };\n\n      switch (direction) {\n        case \"up\":\n          newFocusedCell.row -= 1;\n          break;\n\n        case \"down\":\n          newFocusedCell.row += 1;\n          break;\n\n        case \"left\":\n          newFocusedCell.col -= 1;\n          break;\n\n        case \"right\":\n          newFocusedCell.col += 1;\n          break;\n\n        default:\n          break;\n      }\n\n      if (newFocusedCell.row < 0 || newFocusedCell.row >= _this.grid.numRows || newFocusedCell.col < 0 || newFocusedCell.col >= _this.grid.numCols) {\n        return;\n      } // change selection to match new focus cell location\n\n\n      var newSelectionRegions = [Regions.cell(newFocusedCell.row, newFocusedCell.col)];\n      var selectedRegionTransform = _this.props.selectedRegionTransform;\n      var transformedSelectionRegions = selectedRegionTransform != null ? newSelectionRegions.map(function (region) {\n        return selectedRegionTransform(region, e);\n      }) : newSelectionRegions;\n\n      _this.tableHandlers.handleSelection(transformedSelectionRegions);\n\n      _this.tableHandlers.handleFocus(newFocusedCell); // keep the focused cell in view\n\n\n      _this.scrollBodyToFocusedCell(newFocusedCell);\n    }; // no good way to call arrow-key keyboard events from tests\n\n    /* istanbul ignore next */\n\n\n    this.handleFocusMoveInternal = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n\n      if (focusedCell == null) {\n        // halt early if we have a selectedRegionTransform or something else in play that nixes\n        // the focused cell.\n        return;\n      }\n\n      var newFocusedCell = {\n        col: focusedCell.col,\n        focusSelectionIndex: focusedCell.focusSelectionIndex,\n        row: focusedCell.row\n      }; // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one\n\n      if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {\n        var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[0], _this.grid.numRows, _this.grid.numCols);\n        newFocusedCell = {\n          col: focusCellRegion.cols[0],\n          focusSelectionIndex: 0,\n          row: focusCellRegion.rows[0]\n        };\n      } else {\n        if (selectedRegions.length === 0) {\n          _this.handleFocusMove(e, direction);\n\n          return;\n        }\n\n        var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], _this.grid.numRows, _this.grid.numCols);\n\n        if (focusCellRegion.cols[0] === focusCellRegion.cols[1] && focusCellRegion.rows[0] === focusCellRegion.rows[1] && selectedRegions.length === 1) {\n          _this.handleFocusMove(e, direction);\n\n          return;\n        }\n\n        switch (direction) {\n          case \"up\":\n            newFocusedCell = _this.moveFocusCell(\"row\", \"col\", true, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"left\":\n            newFocusedCell = _this.moveFocusCell(\"col\", \"row\", true, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"down\":\n            newFocusedCell = _this.moveFocusCell(\"row\", \"col\", false, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"right\":\n            newFocusedCell = _this.moveFocusCell(\"col\", \"row\", false, newFocusedCell, focusCellRegion);\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (newFocusedCell.row < 0 || newFocusedCell.row >= _this.grid.numRows || newFocusedCell.col < 0 || newFocusedCell.col >= _this.grid.numCols) {\n        return;\n      }\n\n      _this.tableHandlers.handleFocus(newFocusedCell); // keep the focused cell in view\n\n\n      _this.scrollBodyToFocusedCell(newFocusedCell);\n    };\n\n    this.scrollBodyToFocusedCell = function (focusedCell) {\n      var row = focusedCell.row,\n          col = focusedCell.col;\n      var viewportRect = _this.state.viewportRect; // sort keys in normal CSS position order (per the trusty TRBL/\"trouble\" acronym)\n      // tslint:disable:object-literal-sort-keys\n\n      var viewportBounds = {\n        top: viewportRect.top,\n        right: viewportRect.left + viewportRect.width,\n        bottom: viewportRect.top + viewportRect.height,\n        left: viewportRect.left\n      };\n      var focusedCellBounds = {\n        top: _this.grid.getCumulativeHeightBefore(row),\n        right: _this.grid.getCumulativeWidthAt(col),\n        bottom: _this.grid.getCumulativeHeightAt(row),\n        left: _this.grid.getCumulativeWidthBefore(col)\n      }; // tslint:enable:object-literal-sort-keys\n\n      var focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;\n      var focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;\n      var isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;\n      var isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;\n      var ss = {}; // keep the top end of an overly tall focused cell in view when moving left and right\n      // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)\n\n      if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {\n        // scroll up (minus one pixel to avoid clipping the focused-cell border)\n        ss.nextScrollTop = Math.max(0, focusedCellBounds.top - 1);\n      } else if (focusedCellBounds.bottom > viewportBounds.bottom) {\n        // scroll down\n        var scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;\n        ss.nextScrollTop = viewportBounds.top + scrollDelta;\n      } // keep the left end of an overly wide focused cell in view when moving up and down\n\n\n      if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {\n        // scroll left (again minus one additional pixel)\n        ss.nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);\n      } else if (focusedCellBounds.right > viewportBounds.right) {\n        // scroll right\n        var scrollDelta = focusedCellBounds.right - viewportBounds.right;\n        ss.nextScrollLeft = viewportBounds.left + scrollDelta;\n      }\n\n      _this.tableHandlers.syncViewportPosition(ss);\n    };\n\n    this.handleCopy = function (e) {\n      var _a = _this.props,\n          getCellClipboardData = _a.getCellClipboardData,\n          onCopy = _a.onCopy;\n      var selectedRegions = _this.state.selectedRegions;\n\n      if (getCellClipboardData == null) {\n        return;\n      } // prevent \"real\" copy from being called\n\n\n      e.preventDefault();\n      e.stopPropagation();\n      var cells = Regions.enumerateUniqueCells(selectedRegions, _this.grid.numRows, _this.grid.numCols);\n      var sparse = Regions.sparseMapCells(cells, getCellClipboardData);\n\n      if (sparse != null) {\n        var success = Clipboard.copyCells(sparse);\n        onCopy === null || onCopy === void 0 ? void 0 : onCopy(success);\n      }\n    }; // no-op\n\n  }\n\n  TableHotkeys.prototype.setGrid = function (grid) {\n    this.grid = grid;\n  };\n\n  TableHotkeys.prototype.setProps = function (props) {\n    this.props = props;\n  };\n\n  TableHotkeys.prototype.setState = function (state) {\n    this.state = state;\n  };\n  /**\n   * Replaces the selected region at the specified array index, with the\n   * region provided.\n   */\n\n\n  TableHotkeys.prototype.updateSelectedRegionAtIndex = function (region, index) {\n    var _a = this.props,\n        children = _a.children,\n        numRows = _a.numRows;\n    var selectedRegions = this.state.selectedRegions;\n    var numColumns = React.Children.count(children);\n    var maxRowIndex = Math.max(0, numRows - 1);\n    var maxColumnIndex = Math.max(0, numColumns - 1);\n    var clampedNextRegion = Regions.clampRegion(region, maxRowIndex, maxColumnIndex);\n    var nextSelectedRegions = Regions.update(selectedRegions, clampedNextRegion, index);\n    this.tableHandlers.handleSelection(nextSelectedRegions);\n  }; // Quadrant refs\n  // =============\n\n\n  TableHotkeys.prototype.moveFocusCell = function (primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {\n    var selectedRegions = this.state.selectedRegions;\n    var primaryAxisPlural = primaryAxis === \"row\" ? \"rows\" : \"cols\";\n    var secondaryAxisPlural = secondaryAxis === \"row\" ? \"rows\" : \"cols\";\n    var movementDirection = isUpOrLeft ? -1 : +1;\n    var regionIntervalIndex = isUpOrLeft ? 1 : 0; // try moving the cell in the direction along the primary axis\n\n    newFocusedCell[primaryAxis] += movementDirection;\n    var isPrimaryIndexOutOfBounds = isUpOrLeft ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0] : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];\n\n    if (isPrimaryIndexOutOfBounds) {\n      // if we moved outside the bounds of selection region,\n      // move to the start (or end) of the primary axis, and move one along the secondary\n      newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];\n      newFocusedCell[secondaryAxis] += movementDirection;\n      var isSecondaryIndexOutOfBounds = isUpOrLeft ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0] : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];\n\n      if (isSecondaryIndexOutOfBounds) {\n        // if moving along the secondary also moves us outside\n        // go to the start (or end) of the next (or previous region)\n        // (note that if there's only one region you'll be moving to the opposite corner, which is fine)\n        var newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection; // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around\n\n        if (isUpOrLeft ? newFocusCellSelectionIndex < 0 : newFocusCellSelectionIndex >= selectedRegions.length) {\n          newFocusCellSelectionIndex = isUpOrLeft ? selectedRegions.length - 1 : 0;\n        }\n\n        var newFocusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], this.grid.numRows, this.grid.numCols);\n        newFocusedCell = {\n          col: newFocusCellRegion.cols[regionIntervalIndex],\n          focusSelectionIndex: newFocusCellSelectionIndex,\n          row: newFocusCellRegion.rows[regionIntervalIndex]\n        };\n      }\n    }\n\n    return newFocusedCell;\n  };\n\n  return TableHotkeys;\n}();\n\nexport { TableHotkeys };","map":{"version":3,"sources":["../../src/tableHotkeys.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as React from \"react\";\nimport { Clipboard } from \"./common/clipboard\";\nimport { Direction } from \"./common/direction\";\nimport * as FocusedCellUtils from \"./common/internal/focusedCellUtils\";\nimport * as SelectionUtils from \"./common/internal/selectionUtils\";\nimport { RegionCardinality, Regions } from \"./regions\";\nvar TableHotkeys = /** @class */ (function () {\n    function TableHotkeys(props, state, grid, tableHandlers) {\n        var _this = this;\n        this.props = props;\n        this.state = state;\n        this.grid = grid;\n        this.tableHandlers = tableHandlers;\n        // Selection\n        // =========\n        this.selectAll = function (shouldUpdateFocusedCell) {\n            var selectionHandler = _this.tableHandlers.getEnabledSelectionHandler(RegionCardinality.FULL_TABLE);\n            // clicking on upper left hand corner sets selection to \"all\"\n            // regardless of current selection state (clicking twice does not deselect table)\n            selectionHandler([Regions.table()]);\n            if (shouldUpdateFocusedCell) {\n                var newFocusedCellCoordinates = Regions.getFocusCellCoordinatesFromRegion(Regions.table());\n                _this.tableHandlers.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));\n            }\n        };\n        this.handleSelectAllHotkey = function (e) {\n            // prevent \"real\" select all from happening as well\n            e.preventDefault();\n            e.stopPropagation();\n            // selecting-all via the keyboard should not move the focused cell.\n            _this.selectAll(false);\n        };\n        this.handleSelectionResizeUp = function (e) { return _this.handleSelectionResize(e, Direction.UP); };\n        this.handleSelectionResizeDown = function (e) { return _this.handleSelectionResize(e, Direction.DOWN); };\n        this.handleSelectionResizeLeft = function (e) { return _this.handleSelectionResize(e, Direction.LEFT); };\n        this.handleSelectionResizeRight = function (e) { return _this.handleSelectionResize(e, Direction.RIGHT); };\n        this.handleSelectionResize = function (e, direction) {\n            e.preventDefault();\n            e.stopPropagation();\n            var _a = _this.state, focusedCell = _a.focusedCell, selectedRegions = _a.selectedRegions;\n            if (selectedRegions.length === 0) {\n                return;\n            }\n            var index = FocusedCellUtils.getFocusedOrLastSelectedIndex(selectedRegions, focusedCell);\n            var region = selectedRegions[index];\n            var nextRegion = SelectionUtils.resizeRegion(region, direction, focusedCell);\n            _this.updateSelectedRegionAtIndex(nextRegion, index);\n        };\n        // Focus\n        // =====\n        this.handleFocusMoveLeft = function (e) { return _this.handleFocusMove(e, \"left\"); };\n        this.handleFocusMoveLeftInternal = function (e) { return _this.handleFocusMoveInternal(e, \"left\"); };\n        this.handleFocusMoveRight = function (e) { return _this.handleFocusMove(e, \"right\"); };\n        this.handleFocusMoveRightInternal = function (e) { return _this.handleFocusMoveInternal(e, \"right\"); };\n        this.handleFocusMoveUp = function (e) { return _this.handleFocusMove(e, \"up\"); };\n        this.handleFocusMoveUpInternal = function (e) { return _this.handleFocusMoveInternal(e, \"up\"); };\n        this.handleFocusMoveDown = function (e) { return _this.handleFocusMove(e, \"down\"); };\n        this.handleFocusMoveDownInternal = function (e) { return _this.handleFocusMoveInternal(e, \"down\"); };\n        // no good way to call arrow-key keyboard events from tests\n        /* istanbul ignore next */\n        this.handleFocusMove = function (e, direction) {\n            e.preventDefault();\n            e.stopPropagation();\n            var focusedCell = _this.state.focusedCell;\n            if (focusedCell == null) {\n                // halt early if we have a selectedRegionTransform or something else in play that nixes\n                // the focused cell.\n                return;\n            }\n            var newFocusedCell = {\n                col: focusedCell.col,\n                focusSelectionIndex: 0,\n                row: focusedCell.row,\n            };\n            switch (direction) {\n                case \"up\":\n                    newFocusedCell.row -= 1;\n                    break;\n                case \"down\":\n                    newFocusedCell.row += 1;\n                    break;\n                case \"left\":\n                    newFocusedCell.col -= 1;\n                    break;\n                case \"right\":\n                    newFocusedCell.col += 1;\n                    break;\n                default:\n                    break;\n            }\n            if (newFocusedCell.row < 0 ||\n                newFocusedCell.row >= _this.grid.numRows ||\n                newFocusedCell.col < 0 ||\n                newFocusedCell.col >= _this.grid.numCols) {\n                return;\n            }\n            // change selection to match new focus cell location\n            var newSelectionRegions = [Regions.cell(newFocusedCell.row, newFocusedCell.col)];\n            var selectedRegionTransform = _this.props.selectedRegionTransform;\n            var transformedSelectionRegions = selectedRegionTransform != null\n                ? newSelectionRegions.map(function (region) { return selectedRegionTransform(region, e); })\n                : newSelectionRegions;\n            _this.tableHandlers.handleSelection(transformedSelectionRegions);\n            _this.tableHandlers.handleFocus(newFocusedCell);\n            // keep the focused cell in view\n            _this.scrollBodyToFocusedCell(newFocusedCell);\n        };\n        // no good way to call arrow-key keyboard events from tests\n        /* istanbul ignore next */\n        this.handleFocusMoveInternal = function (e, direction) {\n            e.preventDefault();\n            e.stopPropagation();\n            var _a = _this.state, focusedCell = _a.focusedCell, selectedRegions = _a.selectedRegions;\n            if (focusedCell == null) {\n                // halt early if we have a selectedRegionTransform or something else in play that nixes\n                // the focused cell.\n                return;\n            }\n            var newFocusedCell = {\n                col: focusedCell.col,\n                focusSelectionIndex: focusedCell.focusSelectionIndex,\n                row: focusedCell.row,\n            };\n            // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one\n            if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {\n                var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[0], _this.grid.numRows, _this.grid.numCols);\n                newFocusedCell = {\n                    col: focusCellRegion.cols[0],\n                    focusSelectionIndex: 0,\n                    row: focusCellRegion.rows[0],\n                };\n            }\n            else {\n                if (selectedRegions.length === 0) {\n                    _this.handleFocusMove(e, direction);\n                    return;\n                }\n                var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], _this.grid.numRows, _this.grid.numCols);\n                if (focusCellRegion.cols[0] === focusCellRegion.cols[1] &&\n                    focusCellRegion.rows[0] === focusCellRegion.rows[1] &&\n                    selectedRegions.length === 1) {\n                    _this.handleFocusMove(e, direction);\n                    return;\n                }\n                switch (direction) {\n                    case \"up\":\n                        newFocusedCell = _this.moveFocusCell(\"row\", \"col\", true, newFocusedCell, focusCellRegion);\n                        break;\n                    case \"left\":\n                        newFocusedCell = _this.moveFocusCell(\"col\", \"row\", true, newFocusedCell, focusCellRegion);\n                        break;\n                    case \"down\":\n                        newFocusedCell = _this.moveFocusCell(\"row\", \"col\", false, newFocusedCell, focusCellRegion);\n                        break;\n                    case \"right\":\n                        newFocusedCell = _this.moveFocusCell(\"col\", \"row\", false, newFocusedCell, focusCellRegion);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (newFocusedCell.row < 0 ||\n                newFocusedCell.row >= _this.grid.numRows ||\n                newFocusedCell.col < 0 ||\n                newFocusedCell.col >= _this.grid.numCols) {\n                return;\n            }\n            _this.tableHandlers.handleFocus(newFocusedCell);\n            // keep the focused cell in view\n            _this.scrollBodyToFocusedCell(newFocusedCell);\n        };\n        this.scrollBodyToFocusedCell = function (focusedCell) {\n            var row = focusedCell.row, col = focusedCell.col;\n            var viewportRect = _this.state.viewportRect;\n            // sort keys in normal CSS position order (per the trusty TRBL/\"trouble\" acronym)\n            // tslint:disable:object-literal-sort-keys\n            var viewportBounds = {\n                top: viewportRect.top,\n                right: viewportRect.left + viewportRect.width,\n                bottom: viewportRect.top + viewportRect.height,\n                left: viewportRect.left,\n            };\n            var focusedCellBounds = {\n                top: _this.grid.getCumulativeHeightBefore(row),\n                right: _this.grid.getCumulativeWidthAt(col),\n                bottom: _this.grid.getCumulativeHeightAt(row),\n                left: _this.grid.getCumulativeWidthBefore(col),\n            };\n            // tslint:enable:object-literal-sort-keys\n            var focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;\n            var focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;\n            var isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;\n            var isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;\n            var ss = {};\n            // keep the top end of an overly tall focused cell in view when moving left and right\n            // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)\n            if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {\n                // scroll up (minus one pixel to avoid clipping the focused-cell border)\n                ss.nextScrollTop = Math.max(0, focusedCellBounds.top - 1);\n            }\n            else if (focusedCellBounds.bottom > viewportBounds.bottom) {\n                // scroll down\n                var scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;\n                ss.nextScrollTop = viewportBounds.top + scrollDelta;\n            }\n            // keep the left end of an overly wide focused cell in view when moving up and down\n            if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {\n                // scroll left (again minus one additional pixel)\n                ss.nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);\n            }\n            else if (focusedCellBounds.right > viewportBounds.right) {\n                // scroll right\n                var scrollDelta = focusedCellBounds.right - viewportBounds.right;\n                ss.nextScrollLeft = viewportBounds.left + scrollDelta;\n            }\n            _this.tableHandlers.syncViewportPosition(ss);\n        };\n        this.handleCopy = function (e) {\n            var _a = _this.props, getCellClipboardData = _a.getCellClipboardData, onCopy = _a.onCopy;\n            var selectedRegions = _this.state.selectedRegions;\n            if (getCellClipboardData == null) {\n                return;\n            }\n            // prevent \"real\" copy from being called\n            e.preventDefault();\n            e.stopPropagation();\n            var cells = Regions.enumerateUniqueCells(selectedRegions, _this.grid.numRows, _this.grid.numCols);\n            var sparse = Regions.sparseMapCells(cells, getCellClipboardData);\n            if (sparse != null) {\n                var success = Clipboard.copyCells(sparse);\n                onCopy === null || onCopy === void 0 ? void 0 : onCopy(success);\n            }\n        };\n        // no-op\n    }\n    TableHotkeys.prototype.setGrid = function (grid) {\n        this.grid = grid;\n    };\n    TableHotkeys.prototype.setProps = function (props) {\n        this.props = props;\n    };\n    TableHotkeys.prototype.setState = function (state) {\n        this.state = state;\n    };\n    /**\n     * Replaces the selected region at the specified array index, with the\n     * region provided.\n     */\n    TableHotkeys.prototype.updateSelectedRegionAtIndex = function (region, index) {\n        var _a = this.props, children = _a.children, numRows = _a.numRows;\n        var selectedRegions = this.state.selectedRegions;\n        var numColumns = React.Children.count(children);\n        var maxRowIndex = Math.max(0, numRows - 1);\n        var maxColumnIndex = Math.max(0, numColumns - 1);\n        var clampedNextRegion = Regions.clampRegion(region, maxRowIndex, maxColumnIndex);\n        var nextSelectedRegions = Regions.update(selectedRegions, clampedNextRegion, index);\n        this.tableHandlers.handleSelection(nextSelectedRegions);\n    };\n    // Quadrant refs\n    // =============\n    TableHotkeys.prototype.moveFocusCell = function (primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {\n        var selectedRegions = this.state.selectedRegions;\n        var primaryAxisPlural = primaryAxis === \"row\" ? \"rows\" : \"cols\";\n        var secondaryAxisPlural = secondaryAxis === \"row\" ? \"rows\" : \"cols\";\n        var movementDirection = isUpOrLeft ? -1 : +1;\n        var regionIntervalIndex = isUpOrLeft ? 1 : 0;\n        // try moving the cell in the direction along the primary axis\n        newFocusedCell[primaryAxis] += movementDirection;\n        var isPrimaryIndexOutOfBounds = isUpOrLeft\n            ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0]\n            : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];\n        if (isPrimaryIndexOutOfBounds) {\n            // if we moved outside the bounds of selection region,\n            // move to the start (or end) of the primary axis, and move one along the secondary\n            newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];\n            newFocusedCell[secondaryAxis] += movementDirection;\n            var isSecondaryIndexOutOfBounds = isUpOrLeft\n                ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0]\n                : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];\n            if (isSecondaryIndexOutOfBounds) {\n                // if moving along the secondary also moves us outside\n                // go to the start (or end) of the next (or previous region)\n                // (note that if there's only one region you'll be moving to the opposite corner, which is fine)\n                var newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection;\n                // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around\n                if (isUpOrLeft ? newFocusCellSelectionIndex < 0 : newFocusCellSelectionIndex >= selectedRegions.length) {\n                    newFocusCellSelectionIndex = isUpOrLeft ? selectedRegions.length - 1 : 0;\n                }\n                var newFocusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], this.grid.numRows, this.grid.numCols);\n                newFocusedCell = {\n                    col: newFocusCellRegion.cols[regionIntervalIndex],\n                    focusSelectionIndex: newFocusCellSelectionIndex,\n                    row: newFocusCellRegion.rows[regionIntervalIndex],\n                };\n            }\n        }\n        return newFocusedCell;\n    };\n    return TableHotkeys;\n}());\nexport { TableHotkeys };\n//# sourceMappingURL=tableHotkeys.js.map"]},"metadata":{},"sourceType":"module"}