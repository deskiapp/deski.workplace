{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Event name for `postMessage`\n */\nvar MESSAGE_EVENT_DATA = \"blueprint-table-post-message\";\n/**\n * Object that holds state for managing idle callbacks\n */\n\nvar IDLE_STATE = {\n  callbacks: [],\n  triggered: false\n};\n\nvar handleIdle = function (event) {\n  if (event.source !== window || event.data !== MESSAGE_EVENT_DATA) {\n    return;\n  }\n\n  IDLE_STATE.triggered = false;\n  var callback = null;\n\n  if (IDLE_STATE.callbacks.length > 0) {\n    callback = IDLE_STATE.callbacks.shift();\n  }\n\n  if (IDLE_STATE.callbacks.length > 0) {\n    triggerIdleFrame();\n  } // finally, invoke the callback. exceptions will be propagated\n\n\n  if (callback) {\n    callback();\n  }\n}; // check for window since we might be in a headless server environment\n\n\nif (typeof window !== \"undefined\") {\n  if (window.addEventListener != null) {\n    window.addEventListener(\"message\", handleIdle, false);\n  }\n}\n\nvar triggerIdleFrame = function () {\n  if (IDLE_STATE.triggered) {\n    return;\n  }\n\n  IDLE_STATE.triggered = true;\n  /**\n   * This is the magic that will wait for the browser to be \"idle\" before\n   * invoking the callback.\n   *\n   * First, we use nested calls to `requestAnimationFrame` which will cause\n   * the inner callback to be invoked on the NEXT FRAME.\n   *\n   * Then, we call to `postMessage` to invoke the `handleIdle` method only\n   * once the current stack frame is empty.\n   *\n   * With this approach, the idle callback will be invoked at most once per\n   * frame and only after the stack frame is empty.\n   */\n\n  requestAnimationFrame(function () {\n    requestAnimationFrame(function () {\n      postMessage(MESSAGE_EVENT_DATA, \"*\");\n    });\n  });\n};\n/**\n * Invokes the provided callback on the next available frame after the stack\n * frame is empty.\n *\n * At most one callback per frame is invoked, and the callback may be delayed\n * multiple frames until the page is idle.\n *\n * TODO: return a token from this method that allows you to cancel the callback\n * (otherwise the callback list may increase without bound).\n */\n\n\nexport var requestIdleCallback = function (callback) {\n  IDLE_STATE.callbacks.push(callback);\n  triggerIdleFrame();\n};","map":{"version":3,"sources":["../../../src/common/requestIdleCallback.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;AAEH;;AAEG;AACH,IAAM,kBAAkB,GAAG,8BAA3B;AAIA;;AAEG;;AACH,IAAM,UAAU,GAAG;AACf,EAAA,SAAS,EAAE,EADI;AAEf,EAAA,SAAS,EAAE;AAFI,CAAnB;;AAKA,IAAM,UAAU,GAAG,UAAC,KAAD,EAAoB;AACnC,MAAI,KAAK,CAAC,MAAN,KAAiB,MAAjB,IAA2B,KAAK,CAAC,IAAN,KAAe,kBAA9C,EAAkE;AAC9D;AACH;;AAED,EAAA,UAAU,CAAC,SAAX,GAAuB,KAAvB;AAEA,MAAI,QAAQ,GAAG,IAAf;;AACA,MAAI,UAAU,CAAC,SAAX,CAAqB,MAArB,GAA8B,CAAlC,EAAqC;AACjC,IAAA,QAAQ,GAAG,UAAU,CAAC,SAAX,CAAqB,KAArB,EAAX;AACH;;AAED,MAAI,UAAU,CAAC,SAAX,CAAqB,MAArB,GAA8B,CAAlC,EAAqC;AACjC,IAAA,gBAAgB;AACnB,GAdkC,CAgBnC;;;AACA,MAAI,QAAJ,EAAc;AACV,IAAA,QAAQ;AACX;AACJ,CApBD,C,CAsBA;;;AACA,IAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AAC/B,MAAI,MAAM,CAAC,gBAAP,IAA2B,IAA/B,EAAqC;AACjC,IAAA,MAAM,CAAC,gBAAP,CAAwB,SAAxB,EAAmC,UAAnC,EAA+C,KAA/C;AACH;AACJ;;AAED,IAAM,gBAAgB,GAAG,YAAA;AACrB,MAAI,UAAU,CAAC,SAAf,EAA0B;AACtB;AACH;;AACD,EAAA,UAAU,CAAC,SAAX,GAAuB,IAAvB;AAEA;;;;;;;;;;;;AAYG;;AACH,EAAA,qBAAqB,CAAC,YAAA;AAClB,IAAA,qBAAqB,CAAC,YAAA;AAClB,MAAA,WAAW,CAAC,kBAAD,EAAqB,GAArB,CAAX;AACH,KAFoB,CAArB;AAGH,GAJoB,CAArB;AAKH,CAxBD;AA0BA;;;;;;;;;AASG;;;AACH,OAAO,IAAM,mBAAmB,GAAG,UAAC,QAAD,EAAmB;AAClD,EAAA,UAAU,CAAC,SAAX,CAAqB,IAArB,CAA0B,QAA1B;AACA,EAAA,gBAAgB;AACnB,CAHM","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Event name for `postMessage`\n */\nvar MESSAGE_EVENT_DATA = \"blueprint-table-post-message\";\n/**\n * Object that holds state for managing idle callbacks\n */\nvar IDLE_STATE = {\n    callbacks: [],\n    triggered: false,\n};\nvar handleIdle = function (event) {\n    if (event.source !== window || event.data !== MESSAGE_EVENT_DATA) {\n        return;\n    }\n    IDLE_STATE.triggered = false;\n    var callback = null;\n    if (IDLE_STATE.callbacks.length > 0) {\n        callback = IDLE_STATE.callbacks.shift();\n    }\n    if (IDLE_STATE.callbacks.length > 0) {\n        triggerIdleFrame();\n    }\n    // finally, invoke the callback. exceptions will be propagated\n    if (callback) {\n        callback();\n    }\n};\n// check for window since we might be in a headless server environment\nif (typeof window !== \"undefined\") {\n    if (window.addEventListener != null) {\n        window.addEventListener(\"message\", handleIdle, false);\n    }\n}\nvar triggerIdleFrame = function () {\n    if (IDLE_STATE.triggered) {\n        return;\n    }\n    IDLE_STATE.triggered = true;\n    /**\n     * This is the magic that will wait for the browser to be \"idle\" before\n     * invoking the callback.\n     *\n     * First, we use nested calls to `requestAnimationFrame` which will cause\n     * the inner callback to be invoked on the NEXT FRAME.\n     *\n     * Then, we call to `postMessage` to invoke the `handleIdle` method only\n     * once the current stack frame is empty.\n     *\n     * With this approach, the idle callback will be invoked at most once per\n     * frame and only after the stack frame is empty.\n     */\n    requestAnimationFrame(function () {\n        requestAnimationFrame(function () {\n            postMessage(MESSAGE_EVENT_DATA, \"*\");\n        });\n    });\n};\n/**\n * Invokes the provided callback on the next available frame after the stack\n * frame is empty.\n *\n * At most one callback per frame is invoked, and the callback may be delayed\n * multiple frames until the page is idle.\n *\n * TODO: return a token from this method that allows you to cancel the callback\n * (otherwise the callback list may increase without bound).\n */\nexport var requestIdleCallback = function (callback) {\n    IDLE_STATE.callbacks.push(callback);\n    triggerIdleFrame();\n};\n//# sourceMappingURL=requestIdleCallback.js.map"]},"metadata":{},"sourceType":"module"}