{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { RegionCardinality, Regions } from \"../../regions\";\nimport * as Errors from \"../errors\";\n/**\n * Returns the `focusedSelectionIndex` if both the focused cell and that\n * property are defined, or the last index of `selectedRegions` otherwise. If\n * `selectedRegions` is empty, the function always returns `undefined`.\n */\n\nexport function getFocusedOrLastSelectedIndex(selectedRegions, focusedCell) {\n  if (selectedRegions.length === 0) {\n    return undefined;\n  } else if (focusedCell != null) {\n    return focusedCell.focusSelectionIndex;\n  } else {\n    return selectedRegions.length - 1;\n  }\n}\n/**\n * Returns the proper focused cell for the given set of initial conditions.\n */\n\nexport function getInitialFocusedCell(enableFocusedCell, focusedCellFromProps, focusedCellFromState, selectedRegions) {\n  if (!enableFocusedCell) {\n    return undefined;\n  } else if (focusedCellFromProps != null) {\n    // controlled mode\n    return focusedCellFromProps;\n  } else if (focusedCellFromState != null) {\n    // use the current focused cell from state\n    return focusedCellFromState;\n  } else if (selectedRegions.length > 0) {\n    // focus the top-left cell of the last selection\n    var lastIndex = selectedRegions.length - 1;\n    return __assign(__assign({}, Regions.getFocusCellCoordinatesFromRegion(selectedRegions[lastIndex])), {\n      focusSelectionIndex: lastIndex\n    });\n  } else {\n    // focus the top-left cell of the table\n    return {\n      col: 0,\n      row: 0,\n      focusSelectionIndex: 0\n    };\n  }\n}\n/**\n * Returns `true` if the focused cell is located along the top boundary of the\n * provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionTop(region, focusedCell) {\n  return region.rows != null && focusedCell.row === region.rows[0];\n}\n/**\n * Returns `true` if the focused cell is located along the bottom boundary of\n * the provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionBottom(region, focusedCell) {\n  return region.rows != null && focusedCell.row === region.rows[1];\n}\n/**\n * Returns `true` if the focused cell is located along the left boundary of the\n * provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionLeft(region, focusedCell) {\n  return region.cols != null && focusedCell.col === region.cols[0];\n}\n/**\n * Returns `true` if the focused cell is located along the right boundary of the\n * provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionRight(region, focusedCell) {\n  return region.cols != null && focusedCell.col === region.cols[1];\n}\n/**\n * Returns a new cell-coordinates object that includes a focusSelectionIndex property.\n * The returned object will have the proper FocusedCellCoordinates type.\n */\n\nexport function toFullCoordinates(cellCoords, focusSelectionIndex) {\n  if (focusSelectionIndex === void 0) {\n    focusSelectionIndex = 0;\n  }\n\n  return __assign(__assign({}, cellCoords), {\n    focusSelectionIndex: focusSelectionIndex\n  });\n}\n/**\n * Expands an existing region to new region based on the current focused cell.\n * The focused cell is an invariant and should not move as a result of this\n * operation. This function is used, for instance, to expand a selected region\n * on shift+click.\n */\n\nexport function expandFocusedRegion(focusedCell, newRegion) {\n  switch (Regions.getRegionCardinality(newRegion)) {\n    case RegionCardinality.FULL_COLUMNS:\n      {\n        var _a = getExpandedRegionIndices(focusedCell, newRegion, \"col\", \"cols\"),\n            indexStart = _a[0],\n            indexEnd = _a[1];\n\n        return Regions.column(indexStart, indexEnd);\n      }\n\n    case RegionCardinality.FULL_ROWS:\n      {\n        var _b = getExpandedRegionIndices(focusedCell, newRegion, \"row\", \"rows\"),\n            indexStart = _b[0],\n            indexEnd = _b[1];\n\n        return Regions.row(indexStart, indexEnd);\n      }\n\n    case RegionCardinality.CELLS:\n      var _c = getExpandedRegionIndices(focusedCell, newRegion, \"row\", \"rows\"),\n          rowIndexStart = _c[0],\n          rowIndexEnd = _c[1];\n\n      var _d = getExpandedRegionIndices(focusedCell, newRegion, \"col\", \"cols\"),\n          colIndexStart = _d[0],\n          colIndexEnd = _d[1];\n\n      return Regions.cell(rowIndexStart, colIndexStart, rowIndexEnd, colIndexEnd);\n\n    default:\n      // i.e. `case RegionCardinality.FULL_TABLE:`\n      return Regions.table();\n  }\n}\n\nfunction getExpandedRegionIndices(focusedCell, newRegion, focusedCellDimension, regionDimension) {\n  var sourceIndex = focusedCell[focusedCellDimension];\n  var _a = newRegion[regionDimension],\n      destinationIndex = _a[0],\n      destinationIndexEnd = _a[1];\n\n  if (destinationIndex !== destinationIndexEnd) {\n    if (regionDimension === \"rows\") {\n      throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_ROW_REGION);\n    } else if (regionDimension === \"cols\") {\n      throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_COLUMN_REGION);\n    }\n  }\n\n  return sourceIndex <= destinationIndex ? [sourceIndex, destinationIndex] : [destinationIndex, sourceIndex];\n}","map":{"version":3,"sources":["../../../../src/common/internal/focusedCellUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { RegionCardinality, Regions } from \"../../regions\";\nimport * as Errors from \"../errors\";\n/**\n * Returns the `focusedSelectionIndex` if both the focused cell and that\n * property are defined, or the last index of `selectedRegions` otherwise. If\n * `selectedRegions` is empty, the function always returns `undefined`.\n */\nexport function getFocusedOrLastSelectedIndex(selectedRegions, focusedCell) {\n    if (selectedRegions.length === 0) {\n        return undefined;\n    }\n    else if (focusedCell != null) {\n        return focusedCell.focusSelectionIndex;\n    }\n    else {\n        return selectedRegions.length - 1;\n    }\n}\n/**\n * Returns the proper focused cell for the given set of initial conditions.\n */\nexport function getInitialFocusedCell(enableFocusedCell, focusedCellFromProps, focusedCellFromState, selectedRegions) {\n    if (!enableFocusedCell) {\n        return undefined;\n    }\n    else if (focusedCellFromProps != null) {\n        // controlled mode\n        return focusedCellFromProps;\n    }\n    else if (focusedCellFromState != null) {\n        // use the current focused cell from state\n        return focusedCellFromState;\n    }\n    else if (selectedRegions.length > 0) {\n        // focus the top-left cell of the last selection\n        var lastIndex = selectedRegions.length - 1;\n        return __assign(__assign({}, Regions.getFocusCellCoordinatesFromRegion(selectedRegions[lastIndex])), { focusSelectionIndex: lastIndex });\n    }\n    else {\n        // focus the top-left cell of the table\n        return { col: 0, row: 0, focusSelectionIndex: 0 };\n    }\n}\n/**\n * Returns `true` if the focused cell is located along the top boundary of the\n * provided region, or `false` otherwise.\n */\nexport function isFocusedCellAtRegionTop(region, focusedCell) {\n    return region.rows != null && focusedCell.row === region.rows[0];\n}\n/**\n * Returns `true` if the focused cell is located along the bottom boundary of\n * the provided region, or `false` otherwise.\n */\nexport function isFocusedCellAtRegionBottom(region, focusedCell) {\n    return region.rows != null && focusedCell.row === region.rows[1];\n}\n/**\n * Returns `true` if the focused cell is located along the left boundary of the\n * provided region, or `false` otherwise.\n */\nexport function isFocusedCellAtRegionLeft(region, focusedCell) {\n    return region.cols != null && focusedCell.col === region.cols[0];\n}\n/**\n * Returns `true` if the focused cell is located along the right boundary of the\n * provided region, or `false` otherwise.\n */\nexport function isFocusedCellAtRegionRight(region, focusedCell) {\n    return region.cols != null && focusedCell.col === region.cols[1];\n}\n/**\n * Returns a new cell-coordinates object that includes a focusSelectionIndex property.\n * The returned object will have the proper FocusedCellCoordinates type.\n */\nexport function toFullCoordinates(cellCoords, focusSelectionIndex) {\n    if (focusSelectionIndex === void 0) { focusSelectionIndex = 0; }\n    return __assign(__assign({}, cellCoords), { focusSelectionIndex: focusSelectionIndex });\n}\n/**\n * Expands an existing region to new region based on the current focused cell.\n * The focused cell is an invariant and should not move as a result of this\n * operation. This function is used, for instance, to expand a selected region\n * on shift+click.\n */\nexport function expandFocusedRegion(focusedCell, newRegion) {\n    switch (Regions.getRegionCardinality(newRegion)) {\n        case RegionCardinality.FULL_COLUMNS: {\n            var _a = getExpandedRegionIndices(focusedCell, newRegion, \"col\", \"cols\"), indexStart = _a[0], indexEnd = _a[1];\n            return Regions.column(indexStart, indexEnd);\n        }\n        case RegionCardinality.FULL_ROWS: {\n            var _b = getExpandedRegionIndices(focusedCell, newRegion, \"row\", \"rows\"), indexStart = _b[0], indexEnd = _b[1];\n            return Regions.row(indexStart, indexEnd);\n        }\n        case RegionCardinality.CELLS:\n            var _c = getExpandedRegionIndices(focusedCell, newRegion, \"row\", \"rows\"), rowIndexStart = _c[0], rowIndexEnd = _c[1];\n            var _d = getExpandedRegionIndices(focusedCell, newRegion, \"col\", \"cols\"), colIndexStart = _d[0], colIndexEnd = _d[1];\n            return Regions.cell(rowIndexStart, colIndexStart, rowIndexEnd, colIndexEnd);\n        default:\n            // i.e. `case RegionCardinality.FULL_TABLE:`\n            return Regions.table();\n    }\n}\nfunction getExpandedRegionIndices(focusedCell, newRegion, focusedCellDimension, regionDimension) {\n    var sourceIndex = focusedCell[focusedCellDimension];\n    var _a = newRegion[regionDimension], destinationIndex = _a[0], destinationIndexEnd = _a[1];\n    if (destinationIndex !== destinationIndexEnd) {\n        if (regionDimension === \"rows\") {\n            throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_ROW_REGION);\n        }\n        else if (regionDimension === \"cols\") {\n            throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_COLUMN_REGION);\n        }\n    }\n    return sourceIndex <= destinationIndex ? [sourceIndex, destinationIndex] : [destinationIndex, sourceIndex];\n}\n//# sourceMappingURL=focusedCellUtils.js.map"]},"metadata":{},"sourceType":"module"}