{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { requestIdleCallback } from \"./requestIdleCallback\";\n/**\n * This class helps batch updates to large lists.\n *\n * For example, if your React component has many children, updating them all at\n * once may cause jank when reconciling the DOM. This class helps you update\n * only a few children per frame.\n *\n * A typical usage would be:\n *\n * ```tsx\n * public renderChildren = (allChildrenKeys: string[]) => {\n *\n *     batcher.startNewBatch();\n *\n *     allChildrenKeys.forEach((prop1: string, index: number) => {\n *         batcher.addArgsToBatch(prop1, \"prop2\", index);\n *     });\n *\n *     batcher.removeOldAddNew((prop1: string, prop2: string, other: number) => {\n *         return <Child prop1={prop1} prop2={prop2} other={other} />;\n *     });\n *\n *     if (!batcher.isDone()) {\n *         batcher.idleCallback(this.forceUpdate());\n *     }\n *\n *     const currentChildren = batcher.getList();\n *     return currentChildren;\n * }\n *\n * ```\n */\n\nvar Batcher = function () {\n  function Batcher() {\n    var _this = this;\n\n    this.currentObjects = {};\n    this.oldObjects = {};\n    this.batchArgs = {};\n    this.done = true;\n\n    this.handleIdleCallback = function () {\n      var callback = _this.callback;\n      delete _this.callback;\n      callback === null || callback === void 0 ? void 0 : callback();\n    };\n\n    this.mapCurrentObjectKey = function (key) {\n      return _this.currentObjects[key];\n    };\n  }\n  /**\n   * Resets the \"batch\" and \"current\" sets. This essentially clears the cache\n   * and prevents accidental re-use of \"current\" objects.\n   */\n\n\n  Batcher.prototype.reset = function () {\n    this.batchArgs = {};\n    this.oldObjects = this.currentObjects;\n    this.currentObjects = {};\n  };\n  /**\n   * Starts a new \"batch\" argument set\n   */\n\n\n  Batcher.prototype.startNewBatch = function () {\n    this.batchArgs = {};\n  };\n  /**\n   * Stores the variadic arguments to be later batched together.\n   *\n   * The arguments must be simple stringifyable objects.\n   */\n\n\n  Batcher.prototype.addArgsToBatch = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    this.batchArgs[this.getKey(args)] = args;\n  };\n  /**\n   * Compares the set of \"batch\" arguments to the \"current\" set. Creates any\n   * new objects using the callback as a factory. Removes old objects.\n   *\n   * Arguments that are in the \"current\" set but were not part of the last\n   * \"batch\" set are considered candidates for removal. Similarly, Arguments\n   * that are part of the \"batch\" set but not the \"current\" set are candidates\n   * for addition.\n   *\n   * The number of objects added and removed may be limited with the\n   * `...Limit` parameters.\n   *\n   * Finally, the batcher determines if the batching is complete if the\n   * \"current\" arguments match the \"batch\" arguments.\n   */\n\n\n  Batcher.prototype.removeOldAddNew = function (callback, addNewLimit, removeOldLimit, updateLimit) {\n    var _this = this;\n\n    if (addNewLimit === void 0) {\n      addNewLimit = Batcher.DEFAULT_ADD_LIMIT;\n    }\n\n    if (removeOldLimit === void 0) {\n      removeOldLimit = Batcher.DEFAULT_REMOVE_LIMIT;\n    }\n\n    if (updateLimit === void 0) {\n      updateLimit = Batcher.DEFAULT_UPDATE_LIMIT;\n    } // remove old\n\n\n    var keysToRemove = this.setKeysDifference(this.currentObjects, this.batchArgs, removeOldLimit);\n    keysToRemove.forEach(function (key) {\n      return delete _this.currentObjects[key];\n    }); // remove ALL old objects not in batch\n\n    var keysToRemoveOld = this.setKeysDifference(this.oldObjects, this.batchArgs, -1);\n    keysToRemoveOld.forEach(function (key) {\n      return delete _this.oldObjects[key];\n    }); // copy ALL old objects into current objects if not defined\n\n    var keysToShallowCopy = Object.keys(this.oldObjects);\n    keysToShallowCopy.forEach(function (key) {\n      if (_this.currentObjects[key] == null) {\n        _this.currentObjects[key] = _this.oldObjects[key];\n      }\n    }); // update old objects with factory\n\n    var keysToUpdate = this.setKeysIntersection(this.oldObjects, this.currentObjects, updateLimit);\n    keysToUpdate.forEach(function (key) {\n      delete _this.oldObjects[key];\n      _this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key]);\n    }); // add new objects with factory\n\n    var keysToAdd = this.setKeysDifference(this.batchArgs, this.currentObjects, addNewLimit);\n    keysToAdd.forEach(function (key) {\n      return _this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key]);\n    }); // set `done` to true if sets match exactly after add/remove and there\n    // are no \"old objects\" remaining\n\n    this.done = this.setHasSameKeys(this.batchArgs, this.currentObjects) && Object.keys(this.oldObjects).length === 0;\n  };\n  /**\n   * Returns true if the \"current\" set matches the \"batch\" set.\n   */\n\n\n  Batcher.prototype.isDone = function () {\n    return this.done;\n  };\n  /**\n   * Returns all the objects in the \"current\" set.\n   */\n\n\n  Batcher.prototype.getList = function () {\n    return Object.keys(this.currentObjects).map(this.mapCurrentObjectKey);\n  };\n  /**\n   * Registers a callback to be invoked on the next idle frame. If a callback\n   * has already been registered, we do not register a new one.\n   */\n\n\n  Batcher.prototype.idleCallback = function (callback) {\n    if (!this.callback) {\n      this.callback = callback;\n      requestIdleCallback(this.handleIdleCallback);\n    }\n  };\n\n  Batcher.prototype.cancelOutstandingCallback = function () {\n    delete this.callback;\n  };\n  /**\n   * Forcibly overwrites the current list of batched objects. Not recommended\n   * for normal usage.\n   */\n\n\n  Batcher.prototype.setList = function (objectsArgs, objects) {\n    var _this = this;\n\n    this.reset();\n    objectsArgs.forEach(function (args, i) {\n      _this.addArgsToBatch.apply(_this, args);\n\n      _this.currentObjects[_this.getKey(args)] = objects[i];\n    });\n    this.done = true;\n  };\n\n  Batcher.prototype.getKey = function (args) {\n    return args.join(Batcher.ARG_DELIMITER);\n  };\n\n  Batcher.prototype.setKeysDifference = function (a, b, limit) {\n    return this.setKeysOperation(a, b, \"difference\", limit);\n  };\n\n  Batcher.prototype.setKeysIntersection = function (a, b, limit) {\n    return this.setKeysOperation(a, b, \"intersect\", limit);\n  };\n  /**\n   * Compares the keys of A from B -- and performs an \"intersection\" or\n   * \"difference\" operation on the keys.\n   *\n   * Note that the order of operands A and B matters for the \"difference\"\n   * operation.\n   *\n   * Returns an array of at most `limit` keys.\n   */\n\n\n  Batcher.prototype.setKeysOperation = function (a, b, operation, limit) {\n    var result = [];\n    var aKeys = Object.keys(a);\n\n    for (var i = 0; i < aKeys.length && (limit < 0 || result.length < limit); i++) {\n      var key = aKeys[i];\n\n      if (operation === \"difference\" && a[key] && !b[key] || operation === \"intersect\" && a[key] && b[key]) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Returns true of objects `a` and `b` have exactly the same keys.\n   */\n\n\n  Batcher.prototype.setHasSameKeys = function (a, b) {\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n\n    for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {\n      var aKey = aKeys_1[_i];\n\n      if (b[aKey] === undefined) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Batcher.DEFAULT_ADD_LIMIT = 20;\n  Batcher.DEFAULT_UPDATE_LIMIT = 20;\n  Batcher.DEFAULT_REMOVE_LIMIT = 20;\n  Batcher.ARG_DELIMITER = \"|\";\n  return Batcher;\n}();\n\nexport { Batcher };","map":{"version":3,"sources":["../../../src/common/batcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { requestIdleCallback } from \"./requestIdleCallback\";\n/**\n * This class helps batch updates to large lists.\n *\n * For example, if your React component has many children, updating them all at\n * once may cause jank when reconciling the DOM. This class helps you update\n * only a few children per frame.\n *\n * A typical usage would be:\n *\n * ```tsx\n * public renderChildren = (allChildrenKeys: string[]) => {\n *\n *     batcher.startNewBatch();\n *\n *     allChildrenKeys.forEach((prop1: string, index: number) => {\n *         batcher.addArgsToBatch(prop1, \"prop2\", index);\n *     });\n *\n *     batcher.removeOldAddNew((prop1: string, prop2: string, other: number) => {\n *         return <Child prop1={prop1} prop2={prop2} other={other} />;\n *     });\n *\n *     if (!batcher.isDone()) {\n *         batcher.idleCallback(this.forceUpdate());\n *     }\n *\n *     const currentChildren = batcher.getList();\n *     return currentChildren;\n * }\n *\n * ```\n */\nvar Batcher = /** @class */ (function () {\n    function Batcher() {\n        var _this = this;\n        this.currentObjects = {};\n        this.oldObjects = {};\n        this.batchArgs = {};\n        this.done = true;\n        this.handleIdleCallback = function () {\n            var callback = _this.callback;\n            delete _this.callback;\n            callback === null || callback === void 0 ? void 0 : callback();\n        };\n        this.mapCurrentObjectKey = function (key) {\n            return _this.currentObjects[key];\n        };\n    }\n    /**\n     * Resets the \"batch\" and \"current\" sets. This essentially clears the cache\n     * and prevents accidental re-use of \"current\" objects.\n     */\n    Batcher.prototype.reset = function () {\n        this.batchArgs = {};\n        this.oldObjects = this.currentObjects;\n        this.currentObjects = {};\n    };\n    /**\n     * Starts a new \"batch\" argument set\n     */\n    Batcher.prototype.startNewBatch = function () {\n        this.batchArgs = {};\n    };\n    /**\n     * Stores the variadic arguments to be later batched together.\n     *\n     * The arguments must be simple stringifyable objects.\n     */\n    Batcher.prototype.addArgsToBatch = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.batchArgs[this.getKey(args)] = args;\n    };\n    /**\n     * Compares the set of \"batch\" arguments to the \"current\" set. Creates any\n     * new objects using the callback as a factory. Removes old objects.\n     *\n     * Arguments that are in the \"current\" set but were not part of the last\n     * \"batch\" set are considered candidates for removal. Similarly, Arguments\n     * that are part of the \"batch\" set but not the \"current\" set are candidates\n     * for addition.\n     *\n     * The number of objects added and removed may be limited with the\n     * `...Limit` parameters.\n     *\n     * Finally, the batcher determines if the batching is complete if the\n     * \"current\" arguments match the \"batch\" arguments.\n     */\n    Batcher.prototype.removeOldAddNew = function (callback, addNewLimit, removeOldLimit, updateLimit) {\n        var _this = this;\n        if (addNewLimit === void 0) { addNewLimit = Batcher.DEFAULT_ADD_LIMIT; }\n        if (removeOldLimit === void 0) { removeOldLimit = Batcher.DEFAULT_REMOVE_LIMIT; }\n        if (updateLimit === void 0) { updateLimit = Batcher.DEFAULT_UPDATE_LIMIT; }\n        // remove old\n        var keysToRemove = this.setKeysDifference(this.currentObjects, this.batchArgs, removeOldLimit);\n        keysToRemove.forEach(function (key) { return delete _this.currentObjects[key]; });\n        // remove ALL old objects not in batch\n        var keysToRemoveOld = this.setKeysDifference(this.oldObjects, this.batchArgs, -1);\n        keysToRemoveOld.forEach(function (key) { return delete _this.oldObjects[key]; });\n        // copy ALL old objects into current objects if not defined\n        var keysToShallowCopy = Object.keys(this.oldObjects);\n        keysToShallowCopy.forEach(function (key) {\n            if (_this.currentObjects[key] == null) {\n                _this.currentObjects[key] = _this.oldObjects[key];\n            }\n        });\n        // update old objects with factory\n        var keysToUpdate = this.setKeysIntersection(this.oldObjects, this.currentObjects, updateLimit);\n        keysToUpdate.forEach(function (key) {\n            delete _this.oldObjects[key];\n            _this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key]);\n        });\n        // add new objects with factory\n        var keysToAdd = this.setKeysDifference(this.batchArgs, this.currentObjects, addNewLimit);\n        keysToAdd.forEach(function (key) { return (_this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key])); });\n        // set `done` to true if sets match exactly after add/remove and there\n        // are no \"old objects\" remaining\n        this.done =\n            this.setHasSameKeys(this.batchArgs, this.currentObjects) && Object.keys(this.oldObjects).length === 0;\n    };\n    /**\n     * Returns true if the \"current\" set matches the \"batch\" set.\n     */\n    Batcher.prototype.isDone = function () {\n        return this.done;\n    };\n    /**\n     * Returns all the objects in the \"current\" set.\n     */\n    Batcher.prototype.getList = function () {\n        return Object.keys(this.currentObjects).map(this.mapCurrentObjectKey);\n    };\n    /**\n     * Registers a callback to be invoked on the next idle frame. If a callback\n     * has already been registered, we do not register a new one.\n     */\n    Batcher.prototype.idleCallback = function (callback) {\n        if (!this.callback) {\n            this.callback = callback;\n            requestIdleCallback(this.handleIdleCallback);\n        }\n    };\n    Batcher.prototype.cancelOutstandingCallback = function () {\n        delete this.callback;\n    };\n    /**\n     * Forcibly overwrites the current list of batched objects. Not recommended\n     * for normal usage.\n     */\n    Batcher.prototype.setList = function (objectsArgs, objects) {\n        var _this = this;\n        this.reset();\n        objectsArgs.forEach(function (args, i) {\n            _this.addArgsToBatch.apply(_this, args);\n            _this.currentObjects[_this.getKey(args)] = objects[i];\n        });\n        this.done = true;\n    };\n    Batcher.prototype.getKey = function (args) {\n        return args.join(Batcher.ARG_DELIMITER);\n    };\n    Batcher.prototype.setKeysDifference = function (a, b, limit) {\n        return this.setKeysOperation(a, b, \"difference\", limit);\n    };\n    Batcher.prototype.setKeysIntersection = function (a, b, limit) {\n        return this.setKeysOperation(a, b, \"intersect\", limit);\n    };\n    /**\n     * Compares the keys of A from B -- and performs an \"intersection\" or\n     * \"difference\" operation on the keys.\n     *\n     * Note that the order of operands A and B matters for the \"difference\"\n     * operation.\n     *\n     * Returns an array of at most `limit` keys.\n     */\n    Batcher.prototype.setKeysOperation = function (a, b, operation, limit) {\n        var result = [];\n        var aKeys = Object.keys(a);\n        for (var i = 0; i < aKeys.length && (limit < 0 || result.length < limit); i++) {\n            var key = aKeys[i];\n            if ((operation === \"difference\" && a[key] && !b[key]) || (operation === \"intersect\" && a[key] && b[key])) {\n                result.push(key);\n            }\n        }\n        return result;\n    };\n    /**\n     * Returns true of objects `a` and `b` have exactly the same keys.\n     */\n    Batcher.prototype.setHasSameKeys = function (a, b) {\n        var aKeys = Object.keys(a);\n        var bKeys = Object.keys(b);\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {\n            var aKey = aKeys_1[_i];\n            if (b[aKey] === undefined) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Batcher.DEFAULT_ADD_LIMIT = 20;\n    Batcher.DEFAULT_UPDATE_LIMIT = 20;\n    Batcher.DEFAULT_REMOVE_LIMIT = 20;\n    Batcher.ARG_DELIMITER = \"|\";\n    return Batcher;\n}());\nexport { Batcher };\n//# sourceMappingURL=batcher.js.map"]},"metadata":{},"sourceType":"module"}