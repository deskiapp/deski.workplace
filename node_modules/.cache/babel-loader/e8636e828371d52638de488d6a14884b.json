{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { RegionCardinality, Regions } from \"../../regions\";\n/**\n * Returns the scroll{Left,Top} offsets of the provided region based on its\n * cardinality.\n */\n\nexport function getScrollPositionForRegion(region, currScrollLeft, currScrollTop, getLeftOffset, getTopOffset, numFrozenRows, numFrozenColumns) {\n  if (numFrozenRows === void 0) {\n    numFrozenRows = 0;\n  }\n\n  if (numFrozenColumns === void 0) {\n    numFrozenColumns = 0;\n  }\n\n  var cardinality = Regions.getRegionCardinality(region);\n  var scrollTop = currScrollTop;\n  var scrollLeft = currScrollLeft; // if these were max-frozen-index values, we would have added 1 before passing to the get*Offset\n  // functions, but the counts are already 1-indexed, so we can just pass those.\n\n  var frozenColumnsCumulativeWidth = getLeftOffset(numFrozenColumns);\n  var frozenRowsCumulativeHeight = getTopOffset(numFrozenRows);\n\n  switch (cardinality) {\n    case RegionCardinality.CELLS:\n      {\n        // scroll to the top-left corner of the block of cells\n        var topOffset = getTopOffset(region.rows[0]);\n        var leftOffset = getLeftOffset(region.cols[0]);\n        scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);\n        scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);\n        break;\n      }\n\n    case RegionCardinality.FULL_ROWS:\n      {\n        // scroll to the top of the row block\n        var topOffset = getTopOffset(region.rows[0]);\n        scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);\n        break;\n      }\n\n    case RegionCardinality.FULL_COLUMNS:\n      {\n        // scroll to the left side of the column block\n        var leftOffset = getLeftOffset(region.cols[0]);\n        scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);\n        break;\n      }\n\n    default:\n      {\n        // if it's a FULL_TABLE region, scroll back to the top-left cell of the table\n        scrollTop = 0;\n        scrollLeft = 0;\n        break;\n      }\n  }\n\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n/**\n * Returns the thickness of the target scroll bar in pixels.\n * If the target scroll bar is not present, 0 is returned.\n */\n\nexport function measureScrollBarThickness(element, direction) {\n  if (element == null) {\n    return 0;\n  } // offset size includes the scroll bar. client size does not.\n  // the difference gives the thickness of the scroll bar.\n\n\n  return direction === \"horizontal\" ? element.offsetHeight - element.clientHeight : element.offsetWidth - element.clientWidth;\n}\n/**\n * Adjust the scroll position to align content just beyond the frozen region, if necessary.\n */\n\nfunction getClampedScrollPosition(scrollOffset, frozenRegionCumulativeSize) {\n  // if the new scroll offset falls within the frozen region, clamp it to 0\n  return Math.max(scrollOffset - frozenRegionCumulativeSize, 0);\n}","map":{"version":3,"sources":["../../../../src/common/internal/scrollUtils.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,SAAiB,iBAAjB,EAAoC,OAApC,QAAmD,eAAnD;AAEA;;;AAGG;;AACH,OAAM,SAAU,0BAAV,CACF,MADE,EAEF,cAFE,EAGF,aAHE,EAIF,aAJE,EAKF,YALE,EAMF,aANE,EAOF,gBAPE,EAO0B;AAD5B,MAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,aAAA,GAAA,CAAA;AAAyB;;AACzB,MAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,gBAAA,GAAA,CAAA;AAA4B;;AAE5B,MAAM,WAAW,GAAG,OAAO,CAAC,oBAAR,CAA6B,MAA7B,CAApB;AAEA,MAAI,SAAS,GAAG,aAAhB;AACA,MAAI,UAAU,GAAG,cAAjB,CAL4B,CAO5B;AACA;;AACA,MAAM,4BAA4B,GAAG,aAAa,CAAC,gBAAD,CAAlD;AACA,MAAM,0BAA0B,GAAG,YAAY,CAAC,aAAD,CAA/C;;AAEA,UAAQ,WAAR;AACI,SAAK,iBAAiB,CAAC,KAAvB;AAA8B;AAC1B;AACA,YAAM,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAD,CAA9B;AACA,YAAM,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAD,CAAhC;AACA,QAAA,SAAS,GAAG,wBAAwB,CAAC,SAAD,EAAY,0BAAZ,CAApC;AACA,QAAA,UAAU,GAAG,wBAAwB,CAAC,UAAD,EAAa,4BAAb,CAArC;AACA;AACH;;AACD,SAAK,iBAAiB,CAAC,SAAvB;AAAkC;AAC9B;AACA,YAAM,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAD,CAA9B;AACA,QAAA,SAAS,GAAG,wBAAwB,CAAC,SAAD,EAAY,0BAAZ,CAApC;AACA;AACH;;AACD,SAAK,iBAAiB,CAAC,YAAvB;AAAqC;AACjC;AACA,YAAM,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC,IAAP,CAAY,CAAZ,CAAD,CAAhC;AACA,QAAA,UAAU,GAAG,wBAAwB,CAAC,UAAD,EAAa,4BAAb,CAArC;AACA;AACH;;AACD;AAAS;AACL;AACA,QAAA,SAAS,GAAG,CAAZ;AACA,QAAA,UAAU,GAAG,CAAb;AACA;AACH;AA1BL;;AA6BA,SAAO;AAAE,IAAA,UAAU,EAAA,UAAZ;AAAc,IAAA,SAAS,EAAA;AAAvB,GAAP;AACH;AAED;;;AAGG;;AACH,OAAM,SAAU,yBAAV,CAAoC,OAApC,EAA0D,SAA1D,EAA8F;AAChG,MAAI,OAAO,IAAI,IAAf,EAAqB;AACjB,WAAO,CAAP;AACH,GAH+F,CAIhG;AACA;;;AACA,SAAO,SAAS,KAAK,YAAd,GACD,OAAO,CAAC,YAAR,GAAuB,OAAO,CAAC,YAD9B,GAED,OAAO,CAAC,WAAR,GAAsB,OAAO,CAAC,WAFpC;AAGH;AAED;;AAEG;;AACH,SAAS,wBAAT,CAAkC,YAAlC,EAAwD,0BAAxD,EAA0F;AACtF;AACA,SAAO,IAAI,CAAC,GAAL,CAAS,YAAY,GAAG,0BAAxB,EAAoD,CAApD,CAAP;AACH","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { RegionCardinality, Regions } from \"../../regions\";\n/**\n * Returns the scroll{Left,Top} offsets of the provided region based on its\n * cardinality.\n */\nexport function getScrollPositionForRegion(region, currScrollLeft, currScrollTop, getLeftOffset, getTopOffset, numFrozenRows, numFrozenColumns) {\n    if (numFrozenRows === void 0) { numFrozenRows = 0; }\n    if (numFrozenColumns === void 0) { numFrozenColumns = 0; }\n    var cardinality = Regions.getRegionCardinality(region);\n    var scrollTop = currScrollTop;\n    var scrollLeft = currScrollLeft;\n    // if these were max-frozen-index values, we would have added 1 before passing to the get*Offset\n    // functions, but the counts are already 1-indexed, so we can just pass those.\n    var frozenColumnsCumulativeWidth = getLeftOffset(numFrozenColumns);\n    var frozenRowsCumulativeHeight = getTopOffset(numFrozenRows);\n    switch (cardinality) {\n        case RegionCardinality.CELLS: {\n            // scroll to the top-left corner of the block of cells\n            var topOffset = getTopOffset(region.rows[0]);\n            var leftOffset = getLeftOffset(region.cols[0]);\n            scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);\n            scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);\n            break;\n        }\n        case RegionCardinality.FULL_ROWS: {\n            // scroll to the top of the row block\n            var topOffset = getTopOffset(region.rows[0]);\n            scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);\n            break;\n        }\n        case RegionCardinality.FULL_COLUMNS: {\n            // scroll to the left side of the column block\n            var leftOffset = getLeftOffset(region.cols[0]);\n            scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);\n            break;\n        }\n        default: {\n            // if it's a FULL_TABLE region, scroll back to the top-left cell of the table\n            scrollTop = 0;\n            scrollLeft = 0;\n            break;\n        }\n    }\n    return { scrollLeft: scrollLeft, scrollTop: scrollTop };\n}\n/**\n * Returns the thickness of the target scroll bar in pixels.\n * If the target scroll bar is not present, 0 is returned.\n */\nexport function measureScrollBarThickness(element, direction) {\n    if (element == null) {\n        return 0;\n    }\n    // offset size includes the scroll bar. client size does not.\n    // the difference gives the thickness of the scroll bar.\n    return direction === \"horizontal\"\n        ? element.offsetHeight - element.clientHeight\n        : element.offsetWidth - element.clientWidth;\n}\n/**\n * Adjust the scroll position to align content just beyond the frozen region, if necessary.\n */\nfunction getClampedScrollPosition(scrollOffset, frozenRegionCumulativeSize) {\n    // if the new scroll offset falls within the frozen region, clamp it to 0\n    return Math.max(scrollOffset - frozenRegionCumulativeSize, 0);\n}\n//# sourceMappingURL=scrollUtils.js.map"]},"metadata":{},"sourceType":"module"}